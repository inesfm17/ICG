<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Museu Virtual de Moda</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            pointer-events: none;
            text-shadow: 1px 1px 1px black;
        }
        #zoomOutBtn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 10px 15px;
            background-color: rgba(0,0,0,0.7);
            color: white;
            border: 1px solid white;
            border-radius: 5px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            display: none;
        }
        #zoomOutBtn:hover {
            background-color: rgba(255,255,255,0.2);
        }
        #wallSelector {
            position: absolute;
            left: 20px;
            top: 90%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }
        /* Estilo base para todos os botões do wallSelector */
        .wall-btn {
            padding: 10px 25px;
            border: 1px solid white;
            color: white;
            font-family: Arial, sans-serif;
            border-radius: 5px;
            cursor: pointer;
            font-weight: normal;
            box-shadow: none;
            transition: background-color 0.3s ease;
        }

        /* Cores específicas */
        .wall-btn.blue {
            background-color: #c8c5c5;
            border-color: #c8c5c5;
            color: #e5841d;
            border: 2px solid #e5841d;
        }
        .wall-btn.blue:hover {
            background-color: #d9d7d7;
        }
        .wall-btn.pink {
            background-color: #f5c4cb;
            border-color: #f5c4cb;
            color: #906749;
            border: 2px solid #906749;
        }
        .wall-btn.pink:hover {
            background-color: #f7d4da;
        }
        .wall-btn.green {
            background-color: #000ff0;
            border-color: #000ff0;
            color: #eef22d;
            border: 2px solid #eef22d;
        }
        .wall-btn.green:hover {
            background-color: #334fff;
        }

    </style>
</head>
<body>
    <div id="Tag3DScene"></div>
    <div id="info">Museu Virtual de Moda • Use o mouse para navegar</div>
    <button id="zoomOutBtn">Voltar à vista geral</button>
    <div id="wallSelector">
        <button class="wall-btn pink" onclick="goToWall('pink')">Balance</button>
        <button class="wall-btn blue" onclick="goToWall('blue')">Energy</button>
        <button class="wall-btn green" onclick="goToWall('green')">Stability</button>
    </div>
    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import TWEEN from 'https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.5.0/dist/tween.esm.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Obter o avatar selecionado da URL
        const urlParams = new URLSearchParams(window.location.search);
        const selectedAvatar = urlParams.get('avatar') || '1'; // Default para avatar 1 se não especificado

        const sceneElements = {
            sceneGraph: null,
            camera: null,
            renderer: null,
            controls: null,
            originalCameraPosition: null,
            originalControlsTarget: null
        };
    
        const helper = {
            initEmptyScene: function (sceneElements) {
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f0f0);
                sceneElements.sceneGraph = scene;

                const width = window.innerWidth;
                const height = window.innerHeight;
                const camera = new THREE.PerspectiveCamera(80, width / height, 1, 100);
                sceneElements.camera = camera;
                camera.position.set(10, 11, 37);
                
                sceneElements.originalCameraPosition = camera.position.clone();
                sceneElements.originalControlsTarget = new THREE.Vector3(0, 0, 0);

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.outputColorSpace = THREE.SRGBColorSpace;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.0;
                document.querySelector("#Tag3DScene").appendChild(renderer.domElement);
                sceneElements.renderer = renderer;

                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.1;
                controls.minDistance = 5;
                controls.maxDistance = 200;
                controls.maxPolarAngle = Math.PI * 0.5; // 90 graus 
                controls.screenSpacePanning = true;
                sceneElements.controls = controls;

                // ILUMINAÇÃO FIXA E ESTÁVEL
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);

                
                // Luz principal vindo de cima e à frente
                const mainLightLeft = new THREE.DirectionalLight(0xfff7e6, 1.2);
                mainLightLeft.position.set(-8, 15, 10);
                mainLightLeft.castShadow = true;
                mainLightLeft.shadow.mapSize.width = 2048;
                mainLightLeft.shadow.mapSize.height = 2048;
                scene.add(mainLightLeft);

                // Luz secundária vindo de cima e à frente-direita (simétrica)
                const mainLightRight = new THREE.DirectionalLight(0xfff7e6, 1.2);
                mainLightRight.position.set(8, 15, 10); // Posição mais à direita
                mainLightRight.castShadow = true;
                mainLightRight.shadow.mapSize.width = 2048;
                mainLightRight.shadow.mapSize.height = 2048;
                scene.add(mainLightRight);

                // Luz de preenchimento central mais forte
                const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
                fillLight.position.set(0, 12, 5); // Posição mais central
                scene.add(fillLight);

                // Luzes fixas para os quadros (aumentei a intensidade para 40)
                const frameLight1 = new THREE.SpotLight(0xfff7e6, 40, 20, Math.PI/6, 0.7);
                frameLight1.position.set(-15, 12, -35);
                frameLight1.target.position.set(-15, 7.5, -37.5);
                scene.add(frameLight1);
                scene.add(frameLight1.target);

                const frameLight2 = new THREE.SpotLight(0xfff7e6, 40, 20, Math.PI/6, 0.7);
                frameLight2.position.set(15, 12, -35);
                frameLight2.target.position.set(15, 7.5, -37.5);
                scene.add(frameLight2);
                scene.add(frameLight2.target);

                // Luz ambiente adicional para o centro da sala (aumentei o alcance)
                const centerLight = new THREE.PointLight(0xfff7e6, 20, 20);
                centerLight.position.set(0, 10, 0);
                scene.add(centerLight);

                // Luz esquerda lateral (parede esquerda)
                const leftWallLight = new THREE.DirectionalLight(0xfff7e6, 0.8);
                leftWallLight.position.set(-15, 10, 0);
                leftWallLight.target.position.set(-10, 5, 0);
                scene.add(leftWallLight);
                scene.add(leftWallLight.target);

                // Luz direita lateral (parede direita)
                const rightWallLight = new THREE.DirectionalLight(0xfff7e6, 0.8);
                rightWallLight.position.set(15, 10, 0);
                rightWallLight.target.position.set(10, 5, 0);
                scene.add(rightWallLight);
                scene.add(rightWallLight.target);

            },

            render: function (sceneElements) {
                TWEEN.update();
                sceneElements.controls.update();
                sceneElements.renderer.render(sceneElements.sceneGraph, sceneElements.camera);
                requestAnimationFrame(() => helper.render(sceneElements));
            },

            setupDoubleClickZoom: function(sceneElements) {
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();
                
                function onDoubleClick(event) {
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

                    raycaster.setFromCamera(mouse, sceneElements.camera);

                    const intersects = raycaster.intersectObjects(
                        sceneElements.sceneGraph.children.filter(obj => 
                            obj.userData && obj.userData.isDisplay
                        )
                    );

                    if (intersects.length > 0) {
                        const mockup = intersects[0].object;
                        const frameWidth = 6;

                        const zoomDistance = frameWidth * 1.5;

                        // 1. Obter direção frontal do mockup (no sistema local)
                        // Vamos assumir que a frente está no eixo Z negativo local (ajuste se necessário)
                        const frontDir = new THREE.Vector3(0, 0, -1);
                        frontDir.applyQuaternion(mockup.quaternion).normalize();

                        // 2. Posição da câmera: afastada na direção oposta da frente do mockup
                        const zoomPosition = new THREE.Vector3()
                            .copy(mockup.position)
                            .addScaledVector(frontDir, -zoomDistance);

                        // Manter a altura da câmera alinhada com o mockup, ou ajustar conforme desejar
                        zoomPosition.y = mockup.position.y + 0.5; // ajuste altura para melhor visão

                        // 3. Alvo da câmera será o centro do mockup
                        const targetPosition = mockup.position.clone();

                        // 4. Calcular rotação para câmera olhar de frente para o mockup
                        const directionToMockup = new THREE.Vector3()
                            .subVectors(targetPosition, zoomPosition)
                            .normalize();

                        const targetRotation = new THREE.Quaternion()
                            .setFromUnitVectors(
                                new THREE.Vector3(0, 0, 1),  // vetor "para frente" da câmera padrão
                                directionToMockup
                            );

                        // Tween para a posição da câmera
                        new TWEEN.Tween(sceneElements.camera.position)
                            .to(zoomPosition, 1000)
                            .easing(TWEEN.Easing.Quadratic.Out)
                            .start();

                        // Tween para o target do controle
                        new TWEEN.Tween(sceneElements.controls.target)
                            .to(targetPosition, 1000)
                            .easing(TWEEN.Easing.Quadratic.Out)
                            .start();

                        // Tween para rotação da câmera
                        new TWEEN.Tween({
                            x: sceneElements.camera.quaternion.x,
                            y: sceneElements.camera.quaternion.y,
                            z: sceneElements.camera.quaternion.z,
                            w: sceneElements.camera.quaternion.w
                        })
                        .to({
                            x: targetRotation.x,
                            y: targetRotation.y,
                            z: targetRotation.z,
                            w: targetRotation.w
                        }, 1000)
                        .easing(TWEEN.Easing.Quadratic.Out)
                        .onUpdate(function() {
                            sceneElements.camera.quaternion.set(
                                this.x, this.y, this.z, this.w
                            );
                        })
                        .start();

                        document.getElementById('zoomOutBtn').style.display = 'block';
                    }
                }

                
                window.addEventListener('dblclick', onDoubleClick);
                
                document.getElementById('zoomOutBtn').addEventListener('click', function () {
                    const camPosition = sceneElements.originalCameraPosition;
                    const camTarget = sceneElements.originalControlsTarget;
                    const avatarPosition = sceneElements.originalAvatarPosition;
                    const avatarRotationY = sceneElements.originalAvatarRotationY;

                    // Anima a câmara de volta
                    new TWEEN.Tween(sceneElements.camera.position)
                        .to({ x: camPosition.x, y: camPosition.y, z: camPosition.z }, 1000)
                        .easing(TWEEN.Easing.Quadratic.Out)
                        .start();

                    new TWEEN.Tween(sceneElements.controls.target)
                        .to({ x: camTarget.x, y: camTarget.y, z: camTarget.z }, 1000)
                        .easing(TWEEN.Easing.Quadratic.Out)
                        .start();

                    // Anima o avatar de volta
                    if (sceneElements.avatar) {
                        new TWEEN.Tween(sceneElements.avatar.position)
                            .to({ x: avatarPosition.x, y: avatarPosition.y, z: avatarPosition.z }, 1000)
                            .easing(TWEEN.Easing.Quadratic.Out)
                            .start();

                        new TWEEN.Tween(sceneElements.avatar.rotation)
                            .to({ y: avatarRotationY }, 1000)
                            .easing(TWEEN.Easing.Quadratic.Out)
                            .start();
                    }

                    // Opcional: ocultar botão após zoom out
                    setTimeout(() => {
                        document.getElementById('zoomOutBtn').style.display = 'none';
                    }, 1000);
                });

            }
        };

        const scene = {

            load3DObjects: function (sceneGraph) {

                const textureLoader = new THREE.TextureLoader();
                
                const wallTexture = textureLoader.load('stone-texture.jpg');

                const wallMaterial = new THREE.MeshStandardMaterial({
                    map: wallTexture,
                    roughness: 0.5,
                    metalness: 0.0
                });

                const floorTexture = textureLoader.load('stone-texture.jpg');

                const floorMaterial = new THREE.MeshStandardMaterial({
                    map: floorTexture,
                    roughness: 0.5,
                    metalness: 0.0
                });
                const roomWidth = 50;
                const roomDepth = 80;
                const wallHeight = 15;
                const wallThickness = 0.5;

                // Chão
                const floor = new THREE.Mesh(
                    new THREE.PlaneGeometry(roomWidth, roomDepth),
                    floorMaterial
                );
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                sceneGraph.add(floor);

                // Paredes
                const walls = new THREE.Group();
                
                const backWall = new THREE.Mesh(
                    new THREE.BoxGeometry(roomWidth, wallHeight, wallThickness),
                    wallMaterial
                );
                backWall.position.set(0, wallHeight/2, -roomDepth/2);
                walls.add(backWall);
                
                const leftWall = new THREE.Mesh(
                    new THREE.BoxGeometry(wallThickness, wallHeight, roomDepth),
                    wallMaterial
                );
                leftWall.position.set(-roomWidth/2, wallHeight/2, 0);
                walls.add(leftWall);
                
                const rightWall = leftWall.clone();
                rightWall.position.set(roomWidth/2, wallHeight/2, 0);
                walls.add(rightWall);
                
                sceneGraph.add(walls);

               // PAREDE FRONTAL COM ABERTURA PARA PORTA
                const doorWidth = 6.5;
                const doorHeight = 9.0;
                const wallSideWidth = (roomWidth - doorWidth) / 2;

               // Substitua a parte da parede frontal por este código:
                const frontWallTexture = textureLoader.load('stone-texture.jpg', (texture) => {
                    // Use as mesmas configurações das outras paredes
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(2, 2); // Mesmo repeat das outras paredes
                    
                    const frontWallMaterial = new THREE.MeshStandardMaterial({
                        map: texture,
                        roughness: 0.5,
                        metalness: 0.0
                    });

                    const frontWall = new THREE.Mesh(
                        new THREE.PlaneGeometry(roomWidth, wallHeight),
                        frontWallMaterial
                    );
                    
                    // Posicionar a parede
                    frontWall.position.set(0, wallHeight/2, roomDepth/2);
                    frontWall.rotation.y = Math.PI; // Girar para ficar virada para dentro
                    
                    const doorTexture = textureLoader.load('wood-texture.jpg', (texture) => {
                        texture.wrapS = THREE.RepeatWrapping;
                        texture.wrapT = THREE.RepeatWrapping;
                        texture.repeat.set(1, 1); // Ajuste conforme necessário
                    });
                    const doorMaterial = new THREE.MeshStandardMaterial({
                        color: new THREE.Color ("#f5e1ce"),
                        roughness: 0.0,
                        metalness: 0.0
                    });

                    const door = new THREE.Mesh(
                        new THREE.BoxGeometry(doorWidth, doorHeight, wallThickness/2),
                        doorMaterial
                    );
                    door.position.set(0, doorHeight/2, roomDepth/2 + 0.1);
                    door.castShadow = true;
                    
                    // Adicionar ambos à cena
                    sceneGraph.add(frontWall);
                    sceneGraph.add(door);
                });

                // Bancos laterais
                const bench1 = this.createModernBench(-13, -15, Math.PI/2); // Esquerdo
                const bench12 = this.createModernBench(-13, 0, Math.PI/2); // Esquerdo
                const bench13 = this.createModernBench(-13, 15, Math.PI/2); // Esquerdo

                const bench2 = this.createModernBench(15, 0, -Math.PI/2); // Direito
                const bench21 = this.createModernBench(15, -17, -Math.PI/2); // Direito
                const bench22 = this.createModernBench(15, 17, -Math.PI/2); // Direito

                // Banco central virado para trás
                const bench3 = this.createModernBench(6.5, -30, Math.PI); 
                const bench31 = this.createModernBench(-6.5, -30, Math.PI);

                sceneGraph.add(bench1);
                sceneGraph.add(bench12);
                sceneGraph.add(bench13);
                sceneGraph.add(bench2);
                sceneGraph.add(bench21);
                sceneGraph.add(bench22);
                sceneGraph.add(bench3);
                sceneGraph.add(bench31);

                // adicionamos o avatar
                this.addAvatar(sceneGraph, selectedAvatar);
            
                // TETO PLANO COM IMAGEM
                this.addVaultedCeiling(sceneGraph, roomWidth, roomDepth, wallHeight);

                // Quadros para mockups
                this.addPlaceholderFrames(sceneGraph, roomWidth, roomDepth, wallHeight);

                // Colunas do museu
                this.addMuseumColumns(sceneGraph, roomWidth, roomDepth, wallHeight);

                this.addClassicLamp(sceneGraph, roomWidth, roomDepth, wallHeight);
                
                const wallOffset = 1; // margem segura para evitar que fique encostado demais à parede
                const cornerPositions = [
                    { x: -roomWidth / 2 + wallOffset, z: -roomDepth / 2 + wallOffset },
                    { x:  roomWidth / 2 - wallOffset, z: -roomDepth / 2 + wallOffset },
                    { x: -roomWidth / 2 + wallOffset, z:  roomDepth / 2 - wallOffset },
                    { x:  roomWidth / 2 - wallOffset, z:  roomDepth / 2 - wallOffset }
                ];

                cornerPositions.forEach((pos) => {
                    this.addPlantToCorner(sceneGraph, pos.x, pos.z, wallHeight);
                });

                this.addBaseboards(sceneGraph, roomWidth, roomDepth, wallHeight);

            },

            createModernBench: function(positionX, positionZ, rotationY = Math.PI / 2) {
                const benchGroup = new THREE.Group();
                const textureLoader = new THREE.TextureLoader();

                // Carregar a textura da pedra/mármore (mesma das colunas)
                const marbleTexture = textureLoader.load('transferir (16).jpg', (texture) => {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(5, 1);
                    texture.encoding = THREE.sRGBEncoding;
                    texture.anisotropy = 16; // aumenta qualidade da textura
                });

                const marbleMaterial = new THREE.MeshStandardMaterial({
                    map: marbleTexture,
                    color: new THREE.Color("#e8d5b5"), // aplica o mesmo tom/bege das colunas
                    roughness: 0.5,
                    metalness: 0.2,
                    side: THREE.DoubleSide
                });

                const length = 10;
                const width = 1;
                const height = 0.7;
                const legHeight = 1.5;

                // Assento simples (BoxGeometry)
                const seat = new THREE.Mesh(
                    new THREE.BoxGeometry(length, height, width),
                    marbleMaterial
                );
                seat.position.y = legHeight + height / 2;
                seat.castShadow = true;
                seat.receiveShadow = true;
                benchGroup.add(seat);

                // Pernas cilíndricas do banco
                const legGeometry = new THREE.CylinderGeometry(0.05, 0.05, legHeight, 16);
                const legPositions = [
                    { x: -length / 2 + 0.5, z: -width / 2 + 0.1 },
                    { x: length / 2 - 0.5, z: -width / 2 + 0.1 },
                    { x: -length / 2 + 0.5, z: width / 2 - 0.1 },
                    { x: length / 2 - 0.5, z: width / 2 - 0.1 }
                ];
                legPositions.forEach(pos => {
                    const leg = new THREE.Mesh(legGeometry, marbleMaterial);
                    leg.position.set(pos.x, legHeight / 2, pos.z);
                    leg.castShadow = true;
                    leg.receiveShadow = true;
                    benchGroup.add(leg);
                });

                // Barra lateral (apoio do assento)
                const sideBar = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.03, 0.03, length - 1, 16),
                    marbleMaterial
                );
                sideBar.position.set(0, legHeight + 0.02, -width / 2 + 0.15);
                sideBar.rotation.z = Math.PI / 2;
                sideBar.castShadow = true;
                benchGroup.add(sideBar);

                // Apoios para os braços (armrests) simples caixas finas
                const armRestGeometry = new THREE.BoxGeometry(0.1, 0.5, width);
                const armRestLeft = new THREE.Mesh(armRestGeometry, marbleMaterial);
                armRestLeft.position.set(-length / 2 + 0.2, legHeight + 0.7, 0);
                armRestLeft.castShadow = true;
                benchGroup.add(armRestLeft);

                const armRestRight = armRestLeft.clone();
                armRestRight.position.x = length / 2 - 0.2;
                benchGroup.add(armRestRight);

                benchGroup.position.set(positionX, 0, positionZ);
                benchGroup.rotation.y = rotationY;

                return benchGroup;
            },

            addClassicLamp: function(sceneGraph, roomWidth, roomDepth, wallHeight) {
                const textureLoader = new THREE.TextureLoader();
                const marbleTexture = textureLoader.load('transferir (16).jpg');

                const marbleMaterial = new THREE.MeshStandardMaterial({
                    map: marbleTexture,
                    color: new THREE.Color("#e8d5b5"),
                    roughness: 0.5,
                    metalness: 0.2
                });

                // Poste pendurado
                const poleHeight = 3;
                const pole = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, poleHeight, 24),
                    marbleMaterial
                );
                pole.position.y = wallHeight - (poleHeight / 2);

                // Base decorativa no topo do poste
                const topBase = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.6, 0.3, 32),
                    marbleMaterial
                );
                topBase.position.y = wallHeight - poleHeight - 0.15;

                const arms = new THREE.Group();
                const numArms = 4;
                const armLength = 2.5;
                const armRadius = 0.08;
                const lampRadius = 0.7;
                const armY = wallHeight - poleHeight - 0.4;

                for (let i = 0; i < numArms; i++) {
                    const angle = i * (Math.PI / 2);
                    const dirX = Math.cos(angle);
                    const dirZ = Math.sin(angle);

                    // Braço
                    const arm = new THREE.Mesh(
                        new THREE.CylinderGeometry(armRadius, armRadius, armLength, 16),
                        marbleMaterial
                    );

                    arm.position.set(
                        dirX * (armLength / 2),
                        armY,
                        dirZ * (armLength / 2)
                    );

                    // Rodar para apontar para fora
                    arm.rotation.y = -angle;
                    arm.rotation.z = Math.PI / 2;

                    // Esfera decorativa no fim do braço
                    const endCap = new THREE.Mesh(
                        new THREE.SphereGeometry(0.15, 16, 16),
                        marbleMaterial
                    );
                    endCap.position.set(
                        dirX * armLength,
                        armY,
                        dirZ * armLength
                    );

                    // Lâmpada grande
                    const lamp = new THREE.Mesh(
                        new THREE.SphereGeometry(lampRadius, 32, 32),
                        new THREE.MeshStandardMaterial({
                            color: 0xffffcc,
                            emissive: 0xffffaa,
                            emissiveIntensity: 0.6,
                            roughness: 0.2,
                            metalness: 0.1
                        })
                    );
                    lamp.position.set(
                        dirX * armLength,
                        armY - lampRadius - 0.1,
                        dirZ * armLength
                    );

                    // Luz
                    const pointLight = new THREE.PointLight(0xfff2cc, 1.2, 15);
                    pointLight.position.copy(lamp.position);
                    pointLight.castShadow = true;

                    arms.add(arm);
                    arms.add(endCap);
                    arms.add(lamp);
                    arms.add(pointLight);
                }

                const lampGroup = new THREE.Group();
                lampGroup.add(pole);
                lampGroup.add(topBase);
                lampGroup.add(arms);

                lampGroup.position.set(0, 0, 0);
                sceneGraph.add(lampGroup);
            },

            addPlantToCorner: function(sceneGraph, x, z, wallHeight) {
                const potHeight = 1.6;
                const potRadius = 0.9;

                // Vaso robusto
                const pot = new THREE.Mesh(
                    new THREE.CylinderGeometry(potRadius * 0.6, potRadius, potHeight, 32),
                    new THREE.MeshStandardMaterial({ color: 0x8b5a2b }) // castanho terra
                );
                pot.position.y = potHeight / 2;

                // Tronco central (opcional)
                const stemHeight = wallHeight * 0.25;
                const stem = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.12, 0.12, stemHeight, 16),
                    new THREE.MeshStandardMaterial({ color: 0x3e2c1c }) // castanho escuro
                );
                stem.position.y = potHeight + stemHeight / 2;

                // Grupo de folhas finas (cones altos e estreitos)
                const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228b22 });
                const leafGroup = new THREE.Group();
                const numLeaves = 6;
                const maxLeafHeight = wallHeight * 0.6;

                for (let i = 0; i < numLeaves; i++) {
                    const leaf = new THREE.Mesh(
                        new THREE.ConeGeometry(0.15, maxLeafHeight * (0.8 + Math.random() * 0.2), 12),
                        leavesMaterial
                    );

                    const angle = (i / numLeaves) * Math.PI * 2;
                    const radius = 0.5;
                    leaf.position.set(
                        Math.cos(angle) * radius,
                        potHeight + stemHeight,
                        Math.sin(angle) * radius
                    );
                    leaf.rotation.x = Math.random() * 0.2 - 0.1;
                    leaf.rotation.z = Math.random() * 0.2 - 0.1;
                    leafGroup.add(leaf);
                }

                // Agrupar tudo
                const plantGroup = new THREE.Group();
                plantGroup.add(pot);
                plantGroup.add(stem);
                plantGroup.add(leafGroup);

                // Posicionar no canto
                plantGroup.position.set(x, 0, z);

                sceneGraph.add(plantGroup);
            },

            addBaseboards: function(sceneGraph, roomWidth, roomDepth) {
                const baseboardHeight = 0.3;
                const baseboardDepth = 0.2;

                const textureLoader = new THREE.TextureLoader();
                const marbleTexture = textureLoader.load('transferir (16).jpg'); // usar textura do mármore

                const baseboardMaterial = new THREE.MeshStandardMaterial({
                    map: marbleTexture,
                    color: new THREE.Color("#e8d5b5"),
                    roughness: 0.5,
                    metalness: 0.2
                });

                // Criar as 4 partes do rodapé - um contorno em "U"
                
                // Parede frontal e traseira (largura do museu)
                const frontBoard = new THREE.Mesh(
                    new THREE.BoxGeometry(roomWidth, baseboardHeight, baseboardDepth),
                    baseboardMaterial
                );
                frontBoard.position.set(0, baseboardHeight / 2, -roomDepth / 2 + baseboardDepth / 2);
                
                const backBoard = frontBoard.clone();
                backBoard.position.set(0, baseboardHeight / 2, roomDepth / 2 - baseboardDepth / 2);

                // Parede esquerda e direita (profundidade do museu)
                const sideBoard = new THREE.Mesh(
                    new THREE.BoxGeometry(baseboardDepth, baseboardHeight, roomDepth),
                    baseboardMaterial
                );
                sideBoard.position.set(-roomWidth / 2 + baseboardDepth / 2, baseboardHeight / 2, 0);
                
                const otherSideBoard = sideBoard.clone();
                otherSideBoard.position.set(roomWidth / 2 - baseboardDepth / 2, baseboardHeight / 2, 0);

                // Adicionar tudo ao grupo e depois à cena
                const baseboardsGroup = new THREE.Group();
                baseboardsGroup.add(frontBoard);
                baseboardsGroup.add(backBoard);
                baseboardsGroup.add(sideBoard);
                baseboardsGroup.add(otherSideBoard);

                sceneGraph.add(baseboardsGroup);
            },

            addAvatar: function(sceneGraph, avatarType) {
                // Se já existe um avatar na cena, removemos antes
                if (sceneElements.avatar) {
                    sceneGraph.remove(sceneElements.avatar);
                    sceneElements.avatar = null;
                }

                const loader = new GLTFLoader();

                // Mapear avatarType para URLs dos arquivos gltf dos avatares
                let avatarURL;
                switch (avatarType) {
                    case '1':
                        avatarURL = 'avatares/avatarBalance/scene.gltf';  // substitua pelo caminho real
                        break;
                    case '2':
                        avatarURL = 'avatares/avatarEnergy/scene.gltf';
                        break;
                    case '3':
                        avatarURL = 'avatares/avatarStability/scene.gltf';
                        break;
                }

                loader.load(avatarURL, (gltf) => {
                    const avatarModel = gltf.scene;

                    // Ajustar escala, posição e rotação para o padrão
                    avatarModel.scale.set(1.0, 1.0, 1.0);
                    avatarModel.position.set(5, 5, 22);
                    avatarModel.rotation.y = 0.5; // Posição padrão do avatar

                    // Adicionar o modelo na cena
                    sceneGraph.add(avatarModel);

                    // Guardar referência global para manipular depois (movimento, animação)
                    sceneElements.avatar = avatarModel;
                    sceneElements.originalAvatarPosition = avatarModel.position.clone();
                    sceneElements.originalAvatarRotationY = avatarModel.rotation.y;
                },
                undefined,
                (error) => {
                    console.error('Erro ao carregar o avatar GLTF:', error);
                });
            },

            addVaultedCeiling: function(sceneGraph, roomWidth, roomDepth, wallHeight) {
                const textureLoader = new THREE.TextureLoader();
                
                // Carrega apenas a textura do logo
                textureLoader.load('Logo.jpg', (texture) => {
                    const ceilingMaterial = new THREE.MeshStandardMaterial({
                        map: texture,
                        side: THREE.DoubleSide
                    });

                    const ceilingGeometry = new THREE.PlaneGeometry(roomWidth, roomDepth);
                    const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
                    ceiling.rotation.x = Math.PI / 2;
                    ceiling.position.y = wallHeight;
                    sceneGraph.add(ceiling);
                });
            },

            addPlaceholderFrames: function(sceneGraph, roomWidth, roomDepth, wallHeight) {
                const frameMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff, 
                    metalness: 0.1, 
                    roughness: 0.4 
                });

                const frameWidth = 6;
                const frameHeight = 10;
                const frameDepth = 0.3;
                const frameOffset = 0.2;

                const mockupImages = [
                    'mockups/mockup1.png',
                    'mockups/mockup2.png',
                    'mockups/mockup3.png',
                    'mockups/mockup4.png',
                    'mockups/mockup5.png',
                    'mockups/mockup6.png',
                    'mockups/mockup7.png',
                    'mockups/mockup8.png',
                    'mockups/mockup9.png',
                    'mockups/mockup10.png',
                    'mockups/mockup11.png',
                    'mockups/mockup12.png',
                    'mockups/mockup13.png',
                ];

                const framePositions = [
                    { x: -roomWidth/2 + frameOffset, y: wallHeight/2, z: -20, rotY: Math.PI/2, mockupIndex: 1 },
                    { x: -roomWidth/2 + frameOffset, y: wallHeight/2, z: -7,  rotY: Math.PI/2, mockupIndex: 2 },
                    { x: -roomWidth/2 + frameOffset, y: wallHeight/2, z: 7,   rotY: Math.PI/2, mockupIndex: 3 },
                    { x: -roomWidth/2 + frameOffset, y: wallHeight/2, z: 20,  rotY: Math.PI/2, mockupIndex: 4 },

                   { x: -15, y: wallHeight/2, z: -roomDepth/2 + frameOffset, rotY: 0, mockupIndex: 9 },
                   { x: -5,  y: wallHeight/2, z: -roomDepth/2 + frameOffset, rotY: 0, mockupIndex: 10 },
                   { x: 5,   y: wallHeight/2, z: -roomDepth/2 + frameOffset, rotY: 0, mockupIndex: 11 },
                   { x: 15,  y: wallHeight/2, z: -roomDepth/2 + frameOffset, rotY: 0, mockupIndex: 12 },


                    { x: roomWidth/2 - frameOffset, y: wallHeight/2, z: -20, rotY: -Math.PI/2, mockupIndex: 5 },
                    { x: roomWidth/2 - frameOffset, y: wallHeight/2, z: -7,  rotY: -Math.PI/2, mockupIndex: 6 },
                    { x: roomWidth/2 - frameOffset, y: wallHeight/2, z: 7,   rotY: -Math.PI/2, mockupIndex: 7 },
                    { x: roomWidth/2 - frameOffset, y: wallHeight/2, z: 20,  rotY: -Math.PI/2, mockupIndex: 8 }
                ];

                const textureLoader = new THREE.TextureLoader();

                framePositions.forEach((pos) => {
                    const frameGroup = new THREE.Group();

                    const marbleTexture = textureLoader.load("transferir (16).jpg");
                    const frameMaterial = new THREE.MeshStandardMaterial({
                        map: marbleTexture,
                        color: new THREE.Color("#e8d5b5"),
                        roughness: 0.4,
                        metalness: 0.2
                        
                    });

                    // Moldura com bordas mais elegantes
                    const bevel = 0.15;
                    const sideDepth = frameDepth * 0.7;

                    const front = new THREE.Mesh(
                        new THREE.BoxGeometry(frameWidth, frameHeight, frameDepth / 3),
                        frameMaterial
                    );
                    front.position.z = frameDepth / 3;
                    frameGroup.add(front);

                    const left = new THREE.Mesh(
                        new THREE.BoxGeometry(bevel, frameHeight, sideDepth),
                        frameMaterial
                    );
                    left.position.set(-frameWidth / 2 + bevel / 2, 0, sideDepth / 2);
                    frameGroup.add(left);

                    const right = left.clone();
                    right.position.set(frameWidth / 2 - bevel / 2, 0, sideDepth / 2);
                    frameGroup.add(right);

                    const top = new THREE.Mesh(
                        new THREE.BoxGeometry(frameWidth + bevel, bevel, sideDepth),
                        frameMaterial
                    );
                    top.position.set(0, frameHeight / 2 - bevel / 2, sideDepth / 2);
                    frameGroup.add(top);

                    const bottom = top.clone();
                    bottom.position.set(0, -frameHeight / 2 + bevel / 2, sideDepth / 2);
                    frameGroup.add(bottom);

                    // Posicionar moldura
                    frameGroup.position.set(pos.x, pos.y, pos.z);
                    frameGroup.rotation.y = pos.rotY;
                    sceneGraph.add(frameGroup);

                    const imageUrl = mockupImages[pos.mockupIndex];

                    textureLoader.load(
                        imageUrl,
                        (texture) => {
                            texture.colorSpace = THREE.SRGBColorSpace;

                            const mockupMaterial = new THREE.MeshStandardMaterial({
                                map: texture,
                                color: 0xffffff,
                                roughness: 0.0,
                                metalness: 0.0,
                                emissive: new THREE.Color(0x555555),
                                emissiveIntensity: 0.5,
                                side: THREE.DoubleSide
                            });

                            const mockup = new THREE.Mesh(
                                new THREE.PlaneGeometry(frameWidth * 0.9, frameHeight * 0.9),
                                mockupMaterial
                            );

                            mockup.position.copy(frameGroup.position);
                            const forward = new THREE.Vector3(0, 0, 1).applyEuler(new THREE.Euler(0, pos.rotY, 0));
                            mockup.position.add(forward.multiplyScalar(frameDepth / 2 + 0.05));
                            mockup.rotation.y = pos.rotY;

                            mockup.userData.isDisplay = true;
                            sceneGraph.add(mockup);
                        },
                        undefined,
                        (error) => {
                            console.error("Erro ao carregar textura:", imageUrl, error);
                        }
                    );
                });
            },

            addMuseumColumns: function(sceneGraph, roomWidth, roomDepth, wallHeight) {
                const textureLoader = new THREE.TextureLoader();

                // Textura de mármore com alta qualidade
                const marbleTexture = textureLoader.load('transferir (16).jpg', (texture) => {
                    texture.encoding = THREE.sRGBEncoding;
                    texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(1, wallHeight / 3); // menos repetição para evitar padrão óbvio
                    texture.minFilter = THREE.LinearMipmapLinearFilter;
                });

                const columnMaterial = new THREE.MeshStandardMaterial({
                    map: marbleTexture,
                    color: new THREE.Color("#e8d5b5"),
                    roughness: 0.5,
                    metalness: 0.2
                });

                const columnGeometry = new THREE.CylinderGeometry(0.8, 0.8, wallHeight, 32);

                const baseGeometry = new THREE.CylinderGeometry(1, 1, 0.3, 32);
                const capitelGeometry = new THREE.CylinderGeometry(1.1, 1.1, 0.3, 32);

                const columns = [
                    { x: -roomWidth / 3, z: -roomDepth / 3 },
                    { x: roomWidth / 3, z: -roomDepth / 3 },
                    { x: -roomWidth / 3, z: roomDepth / 3 },
                    { x: roomWidth / 3, z: roomDepth / 3 }
                ];

                columns.forEach(pos => {
                    // Base da coluna
                    const base = new THREE.Mesh(baseGeometry, columnMaterial);
                    base.position.set(pos.x, 0.15, pos.z);
                    base.castShadow = true;
                    base.receiveShadow = true;
                    sceneGraph.add(base);

                    // Coluna principal
                    const column = new THREE.Mesh(columnGeometry, columnMaterial);
                    column.position.set(pos.x, wallHeight / 2 + 0.3, pos.z);
                    column.castShadow = true;
                    column.receiveShadow = true;
                    sceneGraph.add(column);

                    // Capitel da coluna
                    const capitel = new THREE.Mesh(capitelGeometry, columnMaterial);
                    capitel.position.set(pos.x, wallHeight + 0.3, pos.z);
                    capitel.castShadow = true;
                    capitel.receiveShadow = true;
                    sceneGraph.add(capitel);
                });
            },
        };

            let lastSelectedWall = null;
            function goToWall(color) {

            let camPosition, camTarget, avatarPosition, avatarRotationY;
            switch(color) {
                case 'blue':
                    camPosition = new THREE.Vector3(0, 7, -5);
                    camTarget = new THREE.Vector3(0, 10, -40);
                    avatarPosition = new THREE.Vector3(0, 1.5, -28);  // y=1.5 para o avatar ficar no chão
                    avatarRotationY = Math.PI;  // 180 em radianos
                    lastSelectedWall = "Energy";
                    break;
                case 'pink':
                    camPosition = new THREE.Vector3(6, 7, 0);
                    camTarget = new THREE.Vector3(0, 7, 0);
                    avatarPosition = new THREE.Vector3(-16, 10, 0);
                    avatarRotationY =  Math.PI+1.5;// Posição padrão do avatar
                    lastSelectedWall = "Balance";
                    break;
                case 'green':
                    camPosition = new THREE.Vector3(-10, 7, 0);
                    camTarget = new THREE.Vector3(70, 7, 0);
                    avatarPosition = new THREE.Vector3(16, 10, 0);
                    avatarRotationY = Math.PI - 1.5;
                    lastSelectedWall = "Stability";
                    break;
                case 'zoomOutBtn':
                    camPosition = sceneElements.originalCameraPosition;
                    camTarget = sceneElements.originalControlsTarget;
                    avatarPosition = new THREE.Vector3(0, 1.5, 20);
                    avatarRotationY = Math.PI / 2; // Posição padrão do avatar
                    break;
            }

            new TWEEN.Tween(sceneElements.camera.position)
                .to({ x: camPosition.x, y: camPosition.y, z: camPosition.z }, 1000)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();

            new TWEEN.Tween(sceneElements.controls.target)
                .to({ x: camTarget.x, y: camTarget.y, z: camTarget.z }, 1000)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();

            if (sceneElements.avatar) {
                new TWEEN.Tween(sceneElements.avatar.position)
                    .to({ x: avatarPosition.x, y: avatarPosition, z: avatarPosition.z }, 1000)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();

                new TWEEN.Tween(sceneElements.avatar.rotation)
                    .to({ y: avatarRotationY }, 1000)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
            }

            document.getElementById('zoomOutBtn').style.display = 'block';
        }
        window.goToWall = goToWall;

        // Controlos com teclado
        window.addEventListener("keydown", (event) => {
            if (!sceneElements.avatar) return;

            const speed = 0.3;
            const avatar = sceneElements.avatar;

            let direction = new THREE.Vector3();

            switch (event.key) {
                case "ArrowUp":
                    direction.z = -1;
                    avatar.rotation.y = Math.PI;
                    break;
                case "ArrowDown":
                    direction.z = 1;
                    avatar.rotation.y = 0;
                    break;
                case "ArrowLeft":
                    direction.x = -1;
                    avatar.rotation.y = -Math.PI / 2;
                    break;
                case "ArrowRight":
                    direction.x = 1;
                    avatar.rotation.y = Math.PI / 2;
                    break;
                default:
                    return;
            }

            direction.normalize();
            avatar.position.addScaledVector(direction, speed);

            function animate() {
                requestAnimationFrame(animate);
                TWEEN.update();
                avatarModel.lookAt(camera.position);
                sceneElements.controls.update();
            }
            animate();
        });

        function init() {
            helper.initEmptyScene(sceneElements);
            scene.load3DObjects(sceneElements.sceneGraph);
            helper.setupDoubleClickZoom(sceneElements);
            helper.render(sceneElements);
            helper.setupAvatarMovement(sceneElements);
        }

        window.addEventListener("resize", () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            sceneElements.avatar.rotation.y = Math.PI / 2; // se ele estava virado para o lado
            sceneElements.camera.aspect = width / height;
            sceneElements.camera.updateProjectionMatrix();
            sceneElements.renderer.setSize(width, height);
        });

        init();
    </script>
</body>
</html>