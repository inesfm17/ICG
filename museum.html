<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Museu Virtual de Moda</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            pointer-events: none;
            text-shadow: 1px 1px 1px black;
        }
        #zoomOutBtn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 10px 15px;
            background-color: rgba(0,0,0,0.7);
            color: white;
            border: 1px solid white;
            border-radius: 5px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            display: none;
        }
        #zoomOutBtn:hover {
            background-color: rgba(255,255,255,0.2);
        }
        #wallSelector {
            position: absolute;
            left: 20px;
            top: 90%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }
        /* Estilo base para todos os botões do wallSelector */
        .wall-btn {
            padding: 8px 12px;
            border: 1px solid white;
            color: white;
            font-family: Arial, sans-serif;
            border-radius: 5px;
            cursor: pointer;
            font-weight: normal;
            box-shadow: none;
            transition: background-color 0.3s ease;
        }

        /* Cores específicas */
        .wall-btn.blue {
            background-color: #a2c5f5;
            border-color: #a2c5f5;
            
        }
        .wall-btn.blue:hover {
            background-color: #b8d4f9;
        }
        .wall-btn.pink {
            background-color: #f5c4cb;
            border-color: #f5c4cb;
            color: #906749;
            border: 1px solid #906749;
        }
        .wall-btn.pink:hover {
            background-color: #f7d4da;
        }
        .wall-btn.green {
            background-color: #b3e6c9;
            border-color: #b3e6c9;
            color: black;
        }
        .wall-btn.green:hover {
            background-color: #c6edd6;
        }

    </style>
</head>
<body>
    <div id="Tag3DScene"></div>
    <div id="info">Museu Virtual de Moda • Use o mouse para navegar</div>
    <button id="zoomOutBtn">Voltar à vista geral</button>
    <div id="wallSelector">
        <button class="wall-btn blue" onclick="goToWall('blue')">Serenidade</button>
        <button class="wall-btn pink" onclick="goToWall('pink')">Balance</button>
        <button class="wall-btn green" onclick="goToWall('green')">Ressurgir</button>
    </div>
    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import TWEEN from 'https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.5.0/dist/tween.esm.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Obter o avatar selecionado da URL
        const urlParams = new URLSearchParams(window.location.search);
        const selectedAvatar = urlParams.get('avatar') || '1'; // Default para avatar 1 se não especificado

        const sceneElements = {
            sceneGraph: null,
            camera: null,
            renderer: null,
            controls: null,
            originalCameraPosition: null,
            originalControlsTarget: null
        };
    
        const helper = {
            initEmptyScene: function (sceneElements) {
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f0f0);
                sceneElements.sceneGraph = scene;

                const width = window.innerWidth;
                const height = window.innerHeight;
                const camera = new THREE.PerspectiveCamera(80, width / height, 1, 100);
                sceneElements.camera = camera;
                camera.position.set(0.5, 8.5, 30);
                
                sceneElements.originalCameraPosition = camera.position.clone();
                sceneElements.originalControlsTarget = new THREE.Vector3(0, 0, 0);

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.outputColorSpace = THREE.SRGBColorSpace;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.0;
                document.querySelector("#Tag3DScene").appendChild(renderer.domElement);
                sceneElements.renderer = renderer;

                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.1;
                controls.minDistance = 5;
                controls.maxDistance = 200;
                controls.maxPolarAngle = Math.PI * 0.5; // 90 graus 
                controls.screenSpacePanning = true;
                sceneElements.controls = controls;

                // ILUMINAÇÃO FIXA E ESTÁVEL
                const ambientLight = new THREE.AmbientLight(0xffffff, 1.4);
                scene.add(ambientLight);

                
                // Luz principal vindo de cima e à frente
                const mainLightLeft = new THREE.DirectionalLight(0xfff7e6, 1.2);
                mainLightLeft.position.set(-8, 15, 10);
                mainLightLeft.castShadow = true;
                mainLightLeft.shadow.mapSize.width = 2048;
                mainLightLeft.shadow.mapSize.height = 2048;
                scene.add(mainLightLeft);

                // Luz secundária vindo de cima e à frente-direita (simétrica)
                const mainLightRight = new THREE.DirectionalLight(0xfff7e6, 1.2);
                mainLightRight.position.set(8, 15, 10); // Posição mais à direita
                mainLightRight.castShadow = true;
                mainLightRight.shadow.mapSize.width = 2048;
                mainLightRight.shadow.mapSize.height = 2048;
                scene.add(mainLightRight);

                // Luz de preenchimento central mais forte
                const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
                fillLight.position.set(0, 12, 5); // Posição mais central
                scene.add(fillLight);

                // Luzes fixas para os quadros (aumentei a intensidade para 40)
                const frameLight1 = new THREE.SpotLight(0xfff7e6, 40, 20, Math.PI/6, 0.7);
                frameLight1.position.set(-15, 12, -35);
                frameLight1.target.position.set(-15, 7.5, -37.5);
                scene.add(frameLight1);
                scene.add(frameLight1.target);

                const frameLight2 = new THREE.SpotLight(0xfff7e6, 40, 20, Math.PI/6, 0.7);
                frameLight2.position.set(15, 12, -35);
                frameLight2.target.position.set(15, 7.5, -37.5);
                scene.add(frameLight2);
                scene.add(frameLight2.target);

                // Luz ambiente adicional para o centro da sala (aumentei o alcance)
                const centerLight = new THREE.PointLight(0xfff7e6, 20, 20);
                centerLight.position.set(0, 10, 0);
                scene.add(centerLight);
            },

            render: function (sceneElements) {
                TWEEN.update();
                sceneElements.controls.update();
                sceneElements.renderer.render(sceneElements.sceneGraph, sceneElements.camera);
                requestAnimationFrame(() => helper.render(sceneElements));
            },

            setupDoubleClickZoom: function(sceneElements) {
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();
                
                function onDoubleClick(event) {
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

                    raycaster.setFromCamera(mouse, sceneElements.camera);

                    const intersects = raycaster.intersectObjects(
                        sceneElements.sceneGraph.children.filter(obj => 
                            obj.userData && obj.userData.isDisplay
                        )
                    );

                    if (intersects.length > 0) {
                        const mockup = intersects[0].object;
                        const frameWidth = 6;

                        const zoomDistance = frameWidth * 1.5;

                        // 1. Obter direção frontal do mockup (no sistema local)
                        // Vamos assumir que a frente está no eixo Z negativo local (ajuste se necessário)
                        const frontDir = new THREE.Vector3(0, 0, -1);
                        frontDir.applyQuaternion(mockup.quaternion).normalize();

                        // 2. Posição da câmera: afastada na direção oposta da frente do mockup
                        const zoomPosition = new THREE.Vector3()
                            .copy(mockup.position)
                            .addScaledVector(frontDir, -zoomDistance);

                        // Manter a altura da câmera alinhada com o mockup, ou ajustar conforme desejar
                        zoomPosition.y = mockup.position.y + 0.5; // ajuste altura para melhor visão

                        // 3. Alvo da câmera será o centro do mockup
                        const targetPosition = mockup.position.clone();

                        // 4. Calcular rotação para câmera olhar de frente para o mockup
                        const directionToMockup = new THREE.Vector3()
                            .subVectors(targetPosition, zoomPosition)
                            .normalize();

                        const targetRotation = new THREE.Quaternion()
                            .setFromUnitVectors(
                                new THREE.Vector3(0, 0, 1),  // vetor "para frente" da câmera padrão
                                directionToMockup
                            );

                        // Tween para a posição da câmera
                        new TWEEN.Tween(sceneElements.camera.position)
                            .to(zoomPosition, 1000)
                            .easing(TWEEN.Easing.Quadratic.Out)
                            .start();

                        // Tween para o target do controle
                        new TWEEN.Tween(sceneElements.controls.target)
                            .to(targetPosition, 1000)
                            .easing(TWEEN.Easing.Quadratic.Out)
                            .start();

                        // Tween para rotação da câmera
                        new TWEEN.Tween({
                            x: sceneElements.camera.quaternion.x,
                            y: sceneElements.camera.quaternion.y,
                            z: sceneElements.camera.quaternion.z,
                            w: sceneElements.camera.quaternion.w
                        })
                        .to({
                            x: targetRotation.x,
                            y: targetRotation.y,
                            z: targetRotation.z,
                            w: targetRotation.w
                        }, 1000)
                        .easing(TWEEN.Easing.Quadratic.Out)
                        .onUpdate(function() {
                            sceneElements.camera.quaternion.set(
                                this.x, this.y, this.z, this.w
                            );
                        })
                        .start();

                        document.getElementById('zoomOutBtn').style.display = 'block';
                    }
                }

                
                window.addEventListener('dblclick', onDoubleClick);
                
                document.getElementById('zoomOutBtn').addEventListener('click', function () {
                    const camPosition = sceneElements.originalCameraPosition;
                    const camTarget = sceneElements.originalControlsTarget;
                    const avatarPosition = sceneElements.originalAvatarPosition;
                    const avatarRotationY = sceneElements.originalAvatarRotationY;

                    // Anima a câmara de volta
                    new TWEEN.Tween(sceneElements.camera.position)
                        .to({ x: camPosition.x, y: camPosition.y, z: camPosition.z }, 1000)
                        .easing(TWEEN.Easing.Quadratic.Out)
                        .start();

                    new TWEEN.Tween(sceneElements.controls.target)
                        .to({ x: camTarget.x, y: camTarget.y, z: camTarget.z }, 1000)
                        .easing(TWEEN.Easing.Quadratic.Out)
                        .start();

                    // Anima o avatar de volta
                    if (sceneElements.avatar) {
                        new TWEEN.Tween(sceneElements.avatar.position)
                            .to({ x: avatarPosition.x, y: avatarPosition.y, z: avatarPosition.z }, 1000)
                            .easing(TWEEN.Easing.Quadratic.Out)
                            .start();

                        new TWEEN.Tween(sceneElements.avatar.rotation)
                            .to({ y: avatarRotationY }, 1000)
                            .easing(TWEEN.Easing.Quadratic.Out)
                            .start();
                    }

                    // Opcional: ocultar botão após zoom out
                    setTimeout(() => {
                        document.getElementById('zoomOutBtn').style.display = 'none';
                    }, 1000);
                });

            }
        };

        const scene = {

            load3DObjects: function (sceneGraph) {

                const textureLoader = new THREE.TextureLoader();
                
                const wallTexture = textureLoader.load('stone-shells-fossil-texture.jpg');

                const wallMaterial = new THREE.MeshStandardMaterial({
                    map: wallTexture,
                    roughness: 0.0,
                    metalness: 0.0
                });

                const floorMaterial = new THREE.MeshStandardMaterial({
                    color: new THREE.Color ("#f5e1ce"),
                    roughness: 0.2,
                    metalness: 0.1,
                    transparent: true,                    
                });

                const roomWidth = 50;
                const roomDepth = 80;
                const wallHeight = 15;
                const wallThickness = 0.5;

                // Chão
                const floor = new THREE.Mesh(
                    new THREE.PlaneGeometry(roomWidth, roomDepth),
                    floorMaterial
                );
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                sceneGraph.add(floor);

                // Paredes
                const walls = new THREE.Group();
                
                const backWall = new THREE.Mesh(
                    new THREE.BoxGeometry(roomWidth, wallHeight, wallThickness),
                    wallMaterial
                );
                backWall.position.set(0, wallHeight/2, -roomDepth/2);
                walls.add(backWall);
                
                const leftWall = new THREE.Mesh(
                    new THREE.BoxGeometry(wallThickness, wallHeight, roomDepth),
                    wallMaterial
                );
                leftWall.position.set(-roomWidth/2, wallHeight/2, 0);
                walls.add(leftWall);
                
                const rightWall = leftWall.clone();
                rightWall.position.set(roomWidth/2, wallHeight/2, 0);
                walls.add(rightWall);
                
                sceneGraph.add(walls);

               // PAREDE FRONTAL COM ABERTURA PARA PORTA
                const doorWidth = 6.5;
                const doorHeight = 9.0;
                const wallSideWidth = (roomWidth - doorWidth) / 2;

               // Substitua a parte da parede frontal por este código:
                const frontWallTexture = textureLoader.load('stone-shells-fossil-texture.jpg', (texture) => {
                    // Use as mesmas configurações das outras paredes
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(2, 2); // Mesmo repeat das outras paredes
                    
                    const frontWallMaterial = new THREE.MeshStandardMaterial({
                        map: texture,
                        roughness: 0.0,
                        metalness: 0.0,
                        side: THREE.DoubleSide
                    });

                    const frontWall = new THREE.Mesh(
                        new THREE.PlaneGeometry(roomWidth, wallHeight),
                        frontWallMaterial
                    );
                    
                    // Posicionar a parede
                    frontWall.position.set(0, wallHeight/2, roomDepth/2);
                    frontWall.rotation.y = Math.PI; // Girar para ficar virada para dentro
                    
                    const doorMaterial = new THREE.MeshStandardMaterial({
                        color: new THREE.Color ("#f5e1ce"),
                        roughness: 0.4,
                        metalness: 0.2
                    });

                    const door = new THREE.Mesh(
                        new THREE.BoxGeometry(doorWidth, doorHeight, wallThickness/2),
                        doorMaterial
                    );
                    door.position.set(0, doorHeight/2, roomDepth/2 + 0.1);
                    door.castShadow = true;
                    
                    // Adicionar ambos à cena
                    sceneGraph.add(frontWall);
                    sceneGraph.add(door);
                });

                // Bancos laterais
                const bench1 = this.createModernBench(-15, 0.0, Math.PI/2); // Esquerdo
                const bench12 = this.createModernBench(-15, -15, Math.PI/2); // Esquerdo
                const bench13 = this.createModernBench(-15, 15, Math.PI/2); // Esquerdo

                const bench2 = this.createModernBench(15, 0.0, -Math.PI/2); // Direito
                const bench21 = this.createModernBench(15, -15, -Math.PI/2); // Direito
                const bench22 = this.createModernBench(15, 15, -Math.PI/2); // Direito

                // Banco central virado para trás
                const bench3 = this.createModernBench(6.5, -30, Math.PI); 
                const bench31 = this.createModernBench(-6.5, -30, Math.PI);

                sceneGraph.add(bench1);
                sceneGraph.add(bench12);
                sceneGraph.add(bench13);
                sceneGraph.add(bench2);
                sceneGraph.add(bench21);
                sceneGraph.add(bench22);
                sceneGraph.add(bench3);
                sceneGraph.add(bench31);

                // adicionamos o avatar
                this.addAvatar(sceneGraph, selectedAvatar);
            
                // TETO PLANO COM IMAGEM
                this.addVaultedCeiling(sceneGraph, roomWidth, roomDepth, wallHeight);

                // Quadros para mockups
                this.addPlaceholderFrames(sceneGraph, roomWidth, roomDepth, wallHeight);

                // Colunas do museu
                this.addMuseumColumns(sceneGraph, roomWidth, roomDepth, wallHeight);
            },

            // BANCO CENTRAL MODERNO
                createModernBench: function(positionX, positionZ, rotationY = Math.PI/2) {
                const benchGroup = new THREE.Group();
                
                const textureLoader = new THREE.TextureLoader();

                // Textura de madeira para o assento
                const woodTexture = textureLoader.load('Wood092_1K_Color.jpg', (texture) => {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(9, 1); // Ajuste conforme necessário
                });

                const woodMaterial = new THREE.MeshStandardMaterial({
                    map: woodTexture,
                    roughness: 0.6,
                    metalness: 0.1,
                    side: THREE.DoubleSide
                });
                
                const metalMaterial = new THREE.MeshStandardMaterial({
                    color: 0xFFD700,
                    metalness: 0.8,
                    roughness: 0.3
                });

                const length = 10; // Reduzi o comprimento para caber melhor no espaço
                const width = 1;
                const height = 0.7;
                const legHeight = 1.5;

                const seat = new THREE.Mesh(
                    new THREE.BoxGeometry(length, height, width),
                    woodMaterial
                );
                seat.position.y = legHeight + height/2;
                seat.castShadow = true;
                benchGroup.add(seat);

                const legGeometry = new THREE.BoxGeometry(0.1, legHeight, 0.1);
                const legPositions = [
                    { x: -length/2 + 0.5, z: -width/2 + 0.1 },
                    { x: length/2 - 0.5, z: -width/2 + 0.1 },
                    { x: -length/2 + 0.5, z: width/2 - 0.1 },
                    { x: length/2 - 0.5, z: width/2 - 0.1 }
                ];
                
                legPositions.forEach(pos => {
                    const leg = new THREE.Mesh(legGeometry, metalMaterial);
                    leg.position.set(pos.x, legHeight/2, pos.z);
                    benchGroup.add(leg);
                });

                const sideBar = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.03, 0.03, length - 1, 8),
                    metalMaterial
                );
                sideBar.position.set(0, legHeight + 0.02, -width/2 + 0.15);
                sideBar.rotation.z = Math.PI/2;
                benchGroup.add(sideBar);

                benchGroup.position.set(positionX, 0, positionZ);
                benchGroup.rotation.y = rotationY;

                return benchGroup;
            },


            addAvatar: function(sceneGraph, avatarType) {
                // Se já existe um avatar na cena, removemos antes
                if (sceneElements.avatar) {
                    sceneGraph.remove(sceneElements.avatar);
                    sceneElements.avatar = null;
                }

                const loader = new GLTFLoader();

                // Mapear avatarType para URLs dos arquivos gltf dos avatares
                let avatarURL;
                switch (avatarType) {
                    case '1':
                        avatarURL = 'avatares/avatarBalance/scene.gltf';  // substitua pelo caminho real
                        break;
                    case '2':
                        avatarURL = 'avatares/avatarBalance/scene.gltf';
                        break;
                    case '3':
                        avatarURL = 'avatares/avatarBalance/scene.gltf';
                        break;
                }

                loader.load(avatarURL, (gltf) => {
                    const avatarModel = gltf.scene;

                    // Ajustar escala, posição e rotação para o padrão
                    avatarModel.scale.set(1.0, 1.0, 1.0);
                    avatarModel.position.set(0, 5, 22);
                    avatarModel.rotation.y = Math.PI ; // Posição padrão do avatar

                    // Adicionar o modelo na cena
                    sceneGraph.add(avatarModel);

                    // Guardar referência global para manipular depois (movimento, animação)
                    sceneElements.avatar = avatarModel;
                    sceneElements.originalAvatarPosition = avatarModel.position.clone();
                    sceneElements.originalAvatarRotationY = avatarModel.rotation.y;

                    // Se você quiser, pode disparar uma função aqui para ativar animações do GLTF
                    // ex: mixer e actions para animação, caso seu gltf tenha animações
                },
                undefined,
                (error) => {
                    console.error('Erro ao carregar o avatar GLTF:', error);
                });
            },

            addVaultedCeiling: function(sceneGraph, roomWidth, roomDepth, wallHeight) {
                const textureLoader = new THREE.TextureLoader();
                
                // Carrega apenas a textura do logo
                textureLoader.load('Logo.jpg', (texture) => {
                    const ceilingMaterial = new THREE.MeshStandardMaterial({
                        map: texture,
                        side: THREE.DoubleSide
                    });

                    const ceilingGeometry = new THREE.PlaneGeometry(roomWidth, roomDepth);
                    const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
                    ceiling.rotation.x = Math.PI / 2;
                    ceiling.position.y = wallHeight;
                    sceneGraph.add(ceiling);
                });
            },

            addPlaceholderFrames: function(sceneGraph, roomWidth, roomDepth, wallHeight) {
                const goldFrameMaterial = new THREE.MeshStandardMaterial({
                    color: 0xFFD700,
                    metalness: 1.0,
                    roughness: 0.2,
                    emissive: 0x886600, // mais vibrante
                    emissiveIntensity: 0.5
                });

                const frameWidth = 6;
                const frameHeight = 10;
                const frameDepth = 0.3;
                const frameOffset = 0.2;

                const mockupImages = [
                    'mockup1.png',
                    'mockup2.png',
                    'mockup3.png',
                    'mockup4.png',
                    'mockup5.png'
                ];

                const framePositions = [
                    { x: -roomWidth/2 + frameOffset, y: wallHeight/2, z: -20, rotY: Math.PI/2, mockupIndex: 1 },
                    { x: -roomWidth/2 + frameOffset, y: wallHeight/2, z: -7,  rotY: Math.PI/2, mockupIndex: 2 },
                    { x: -roomWidth/2 + frameOffset, y: wallHeight/2, z: 7,   rotY: Math.PI/2, mockupIndex: 3 },
                    { x: -roomWidth/2 + frameOffset, y: wallHeight/2, z: 20,  rotY: Math.PI/2, mockupIndex: 4 },

                    { x: -20, y: wallHeight/2, z: -roomDepth/2 + frameOffset, rotY: 0, mockupIndex: 0 },
                    { x: -10, y: wallHeight/2, z: -roomDepth/2 + frameOffset, rotY: 0, mockupIndex: 0 },
                    { x: 0,   y: wallHeight/2, z: -roomDepth/2 + frameOffset, rotY: 0, mockupIndex: 0 },
                    { x: 10,  y: wallHeight/2, z: -roomDepth/2 + frameOffset, rotY: 0, mockupIndex: 0 },
                    { x: 20,  y: wallHeight/2, z: -roomDepth/2 + frameOffset, rotY: 0, mockupIndex: 0 },

                    { x: roomWidth/2 - frameOffset, y: wallHeight/2, z: -20, rotY: -Math.PI/2, mockupIndex: 0 },
                    { x: roomWidth/2 - frameOffset, y: wallHeight/2, z: -7,  rotY: -Math.PI/2, mockupIndex: 0 },
                    { x: roomWidth/2 - frameOffset, y: wallHeight/2, z: 7,   rotY: -Math.PI/2, mockupIndex: 0 },
                    { x: roomWidth/2 - frameOffset, y: wallHeight/2, z: 20,  rotY: -Math.PI/2, mockupIndex: 0 }
                ];

                const textureLoader = new THREE.TextureLoader();

                framePositions.forEach((pos) => {
                    const frameGroup = new THREE.Group();

                    // Criar moldura
                    const front = new THREE.Mesh(
                        new THREE.BoxGeometry(frameWidth, frameHeight, frameDepth/3),
                        goldFrameMaterial
                    );
                    front.position.z = frameDepth/3;
                    frameGroup.add(front);

                    const sideDepth = frameDepth * 0.7;

                    const left = new THREE.Mesh(
                        new THREE.BoxGeometry(frameDepth/2, frameHeight, sideDepth),
                        goldFrameMaterial
                    );
                    left.position.set(-frameWidth/2 + frameDepth/4, 0, sideDepth/2);
                    frameGroup.add(left);

                    const right = left.clone();
                    right.position.set(frameWidth/2 - frameDepth/4, 0, sideDepth/2);
                    frameGroup.add(right);

                    const top = new THREE.Mesh(
                        new THREE.BoxGeometry(frameWidth + frameDepth/2, frameDepth/2, sideDepth),
                        goldFrameMaterial
                    );
                    top.position.set(0, frameHeight/2 - frameDepth/4, sideDepth/2);
                    frameGroup.add(top);

                    const bottom = top.clone();
                    bottom.position.set(0, -frameHeight/2 + frameDepth/4, sideDepth/2);
                    frameGroup.add(bottom);

                    // Posicionar grupo
                    frameGroup.position.set(pos.x, pos.y, pos.z);
                    frameGroup.rotation.y = pos.rotY;
                    sceneGraph.add(frameGroup);

                    const imageUrl = mockupImages[pos.mockupIndex];

                    textureLoader.load(
                        imageUrl,
                        (texture) => {
                            texture.colorSpace = THREE.SRGBColorSpace;

                            const mockupMaterial = new THREE.MeshStandardMaterial({
                                map: texture,
                                roughness: 0.3,
                                metalness: 0.0,
                                side: THREE.DoubleSide,
                                emissive: 0x000000, // sem brilho
                                emissiveIntensity: 0.0,
                                toneMapped: false // mantêm as cores vivas
                            });

                            if (pos.rotY === Math.PI/2) {
                                mockupMaterial.color = new THREE.Color(1.8, 1.8, 1.8); // muito claro, mais que branco
                                mockupMaterial.emissive = new THREE.Color(0xaaaaaa);   // um brilho cinza claro
                                mockupMaterial.emissiveIntensity = 0.2;                // intensificar brilho
                            }
                            const mockup = new THREE.Mesh(
                                new THREE.PlaneGeometry(frameWidth * 0.9, frameHeight * 0.9),
                                mockupMaterial
                            );

                            // Posicionar mockup um pouco na frente da moldura
                            mockup.position.copy(frameGroup.position);
                            const forward = new THREE.Vector3(0, 0, 1).applyEuler(new THREE.Euler(0, pos.rotY, 0));
                            mockup.position.add(forward.multiplyScalar(frameDepth / 2 + 0.05));
                            mockup.rotation.y = pos.rotY;

                            mockup.userData.isDisplay = true;
                            sceneGraph.add(mockup);
                        },
                        undefined,
                        (error) => {
                            console.error('Erro ao carregar textura:', imageUrl, error);

                            const fallbackMockup = new THREE.Mesh(
                                new THREE.PlaneGeometry(frameWidth * 0.9, frameHeight * 0.9),
                                new THREE.MeshStandardMaterial({
                                    color: 0xff00ff,
                                    side: THREE.DoubleSide
                                })
                            );

                            fallbackMockup.position.copy(frameGroup.position);
                            const forward = new THREE.Vector3(0, 0, 1).applyEuler(new THREE.Euler(0, pos.rotY, 0));
                            fallbackMockup.position.add(forward.multiplyScalar(frameDepth / 2 + 0.05));
                            fallbackMockup.rotation.y = pos.rotY;

                            sceneGraph.add(fallbackMockup);
                        }
                    );
                });
            },


            addMuseumColumns: function(sceneGraph, roomWidth, roomDepth, wallHeight) {
                const textureLoader = new THREE.TextureLoader();
    
                // Textura de mármore com alta qualidade
                const marbleTexture = textureLoader.load('transferir (16).jpg', (texture) => {
                    texture.encoding = THREE.sRGBEncoding;
                    texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(10, wallHeight/3); // Ajuste para a altura da coluna
                    texture.minFilter = THREE.LinearMipmapLinearFilter;
                });
                
                const columnMaterial = new THREE.MeshStandardMaterial({
                    color: new THREE.Color("#e8d5b5"),
                    roughness: 0.5,
                    metalness: 0.2
                });
                
                const columnGeometry = new THREE.CylinderGeometry(0.8, 0.8, wallHeight, 32);
                
                const columns = [
                    { x: -roomWidth/3, z: -roomDepth/3 },
                    { x: roomWidth/3, z: -roomDepth/3 },
                    { x: -roomWidth/3, z: roomDepth/3 },
                    { x: roomWidth/3, z: roomDepth/3 }
                ];
                
                columns.forEach(pos => {
                    const column = new THREE.Mesh(columnGeometry, columnMaterial);
                    column.position.set(pos.x, wallHeight/2, pos.z);
                    sceneGraph.add(column);
                });
            },
        };

            function goToWall(color) {
            let camPosition, camTarget, avatarPosition, avatarRotationY;
            switch(color) {
                case 'blue':
                    camPosition = new THREE.Vector3(0, 7, -5);
                    camTarget = new THREE.Vector3(0, 10, -40);
                    avatarPosition = new THREE.Vector3(0, 1.5, -28);  // y=1.5 para o avatar ficar no chão
                    avatarRotationY = Math.PI;  // 180 em radianos
                    break;
                case 'pink':
                    camPosition = new THREE.Vector3(6, 7, 0);
                    camTarget = new THREE.Vector3(0, 7, 0);
                    avatarPosition = new THREE.Vector3(-22, 0, 0);
                    avatarRotationY = Math.PI / 2;
                    break;
                case 'green':
                    camPosition = new THREE.Vector3(-10, 7, 0);
                    camTarget = new THREE.Vector3(70, 7, 0);
                    avatarPosition = new THREE.Vector3(22, 0, 0);
                    avatarRotationY = -Math.PI / 2;
                    break;
                case 'zoomOutBtn':
                    camPosition = sceneElements.originalCameraPosition;
                    camTarget = sceneElements.originalControlsTarget;
                    avatarPosition = new THREE.Vector3(0, 1.5, 20);
                    avatarRotationY = Math.PI / 2; // Posição padrão do avatar
                    break;
            }

            new TWEEN.Tween(sceneElements.camera.position)
                .to({ x: camPosition.x, y: camPosition.y, z: camPosition.z }, 1000)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();

            new TWEEN.Tween(sceneElements.controls.target)
                .to({ x: camTarget.x, y: camTarget.y, z: camTarget.z }, 1000)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();

            if (sceneElements.avatar) {
                new TWEEN.Tween(sceneElements.avatar.position)
                    .to({ x: avatarPosition.x, y: avatarPosition, z: avatarPosition.z }, 1000)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();

                new TWEEN.Tween(sceneElements.avatar.rotation)
                    .to({ y: avatarRotationY }, 1000)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
            }

            document.getElementById('zoomOutBtn').style.display = 'block';
        }
        window.goToWall = goToWall;

        // Controlos com teclado
        window.addEventListener("keydown", (event) => {
            if (!sceneElements.avatar) return;

            const speed = 0.3;
            const avatar = sceneElements.avatar;

            let direction = new THREE.Vector3();

            switch (event.key) {
                case "ArrowUp":
                    direction.z = -1;
                    avatar.rotation.y = Math.PI;
                    break;
                case "ArrowDown":
                    direction.z = 1;
                    avatar.rotation.y = 0;
                    break;
                case "ArrowLeft":
                    direction.x = -1;
                    avatar.rotation.y = -Math.PI / 2;
                    break;
                case "ArrowRight":
                    direction.x = 1;
                    avatar.rotation.y = Math.PI / 2;
                    break;
                default:
                    return;
            }

            direction.normalize();
            avatar.position.addScaledVector(direction, speed);

            function updateCameraFollow() {
                const avatar = sceneElements.avatar;
                const camera = sceneElements.camera;
                const controls = sceneElements.controls;

                if (!avatar || !camera || !controls) return;

                const cameraOffset = new THREE.Vector3(0, 5, -10); // vista ligeiramente elevada e atrás
            }
            function animate() {
                requestAnimationFrame(animate);
                TWEEN.update();
                updateCameraFollow();
                sceneElements.controls.update();
                sceneElements.renderer.render(sceneElements.sceneGraph, sceneElements.camera);
            }
            animate();
        });

        function init() {
            helper.initEmptyScene(sceneElements);
            scene.load3DObjects(sceneElements.sceneGraph);
            helper.setupDoubleClickZoom(sceneElements);
            helper.render(sceneElements);
            helper.setupAvatarMovement(sceneElements);
        }

        window.addEventListener("resize", () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            sceneElements.avatar.rotation.y = Math.PI / 2; // se ele estava virado para o lado
            sceneElements.camera.aspect = width / height;
            sceneElements.camera.updateProjectionMatrix();
            sceneElements.renderer.setSize(width, height);
        });

        init();
    </script>
</body>
</html>